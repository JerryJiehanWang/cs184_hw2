<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
  <head/>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">Jiehan Wang</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

  <p>
    de Casteljau's algorithm is an recursive algorithm to compute Bézier Curve. It takes control points as input, and
    recursively compute the next level control points until there is only one point left, using linear interpolation \((P_{new} = (1-t) * P_0 + t * P_1)\)
    between two points. By change the value, t, to interpolate, the final point p will also be change, and the trajectory
    of p is the Bézier Curve we want to compute.
  </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p1_l0.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 0</figcaption>
      </td>
      <td>
        <img src="images/p1_l1.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 1.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/p1_l2.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 2.</figcaption>
      </td>
      <td>
        <img src="images/p1_l3.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 3.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/p1_l4.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 4.</figcaption>
      </td>
      <td>
        <img src="images/p1_l5.png" align="middle" width="400px"/>
        <figcaption align="middle">Step 5.</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/p1_changed.png" align="middle" width="400px"/>
        <figcaption align="middle">Changed points and t.</figcaption>
      </td>
    <tr/>
  </table>
</div>


<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>
  <p>
    To calculate Bézier surface, we first calculate many Bézier curves in one direction using some
    subset of control points (in cubic Bézier these are 4 points in a set.) Then using the points representation of
    Bézier curves to calculate the 2D Bézier surface in another direction. My implementations is basically follow this intuition.
    I first evaluate the Bézier surface in 1D de Casteljau using the interpolation factor of u for 4 sets of points, each
    set has 4 points. Then I use 1D de Casteljau given the previous Bézier curves to calculate the Bézier surface using
    the interpolation factor of v.
  </p>
  <div align="middle">
  <img src="images/teapot.png" align="middle" width="800px"/>
    <div/>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

    <p>
      Basically, I iterate through all the triangles around a vertex p, get the averaged normal of each triangle and
      stored them into a vector, n, and finally get the normalized n as the average normals for p. Because the implementation
      of a triangle is given to us, as long as we have the face of that triangle. So we only need to iterate through all
      the faces around p. I did this by doing in a while loop. First, get the half edge's twin half edge h, of p,
       (don't forget to store the origin h value to h_orig!), then
      get the face f, by doing h -> face(). In order to change to another face, we simply set h = h -> next() -> twin().
      I stop doing this once the h == h_orig, which I know I go back to the original face. Notice that it is important to
      increment n first by the normal value of triangles then do the while loop condition evaluation, otherwise we will miss
      to calculate the last triangle around this vertex p.
    </p>
  <div align="middle">
  <img src="images/default.png" align="middle" width="800px"/>
  <figcaption align="middle">Default OpenGL shading.</figcaption>
  <img src="images/smoothed.png" align="middle" width="800px"/>
  <figcaption align="middle">smoothed normals.</figcaption>
    <div/>


<h3 align="middle">Part 4: Half-edge flip</h3>


<h3 align="middle">Part 5: Half-edge split</h3>


<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

<h2 align="middle">Section III: Mesh Competition</h2>
<p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Design your own mesh!</h3>

</body>
</html>
