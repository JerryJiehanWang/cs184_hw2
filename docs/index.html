<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
  <head/>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">Jiehan Wang</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

  <p>
    de Casteljau's algorithm is an recursive algorithm to compute Bézier Curve. It takes control points as input, and
    recursively compute the next level control points until there is only one point left, using linear interpolation \((P_{new} = (1-t) * P_0 + t * P_1)\)
    between two points. By change the value, t, to interpolate, the final point p will also be change, and the trajectory
    of p is the Bézier Curve we want to compute.
  </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p1_l0.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 0</i></figcaption>
      </td>
      <td>
        <img src="images/p1_l1.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 1.</i></figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/p1_l2.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 2.</i></figcaption>
      </td>
      <td>
        <img src="images/p1_l3.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 3.</i></figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/p1_l4.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 4.</i></figcaption>
      </td>
      <td>
        <img src="images/p1_l5.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Step 5.</i></figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/p1_changed.png" align="middle" width="400px"/>
        <figcaption align="middle"><i>Changed points and t.</i></figcaption>
      </td>
    <tr/>
  </table>
</div>


<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>
  <p>
    To calculate Bézier surface, we first calculate many Bézier curves in one direction using some
    subset of control points (in cubic Bézier these are 4 points in a set.) Then using the points representation of
    Bézier curves to calculate the 2D Bézier surface in another direction. My implementations is basically follow this intuition.
    I first evaluate the Bézier surface in 1D de Casteljau using the interpolation factor of u for 4 sets of points, each
    set has 4 points. Then I use 1D de Casteljau given the previous Bézier curves to calculate the Bézier surface using
    the interpolation factor of v.
  </p>
  <div align="middle">
  <img src="images/teapot.png" align="middle" width="800px"/>
    <div/>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

    <p>
      Basically, I iterate through all the triangles around a vertex p, get the averaged normal of each triangle and
      stored them into a vector, n, and finally get the normalized n as the average normals for p. Because the implementation
      of a triangle is given to us, as long as we have the face of that triangle. So we only need to iterate through all
      the faces around p. I did this by doing in a while loop. First, get the half edge's twin half edge h, of p,
       (don't forget to store the origin h value to h_orig!), then
      get the face f, by doing h -> face(). In order to change to another face, we simply set h = h -> next() -> twin().
      I stop doing this once the h == h_orig, which I know I go back to the original face. Notice that it is important to
      increment n first by the normal value of triangles then do the while loop condition evaluation, otherwise we will miss
      to calculate the last triangle around this vertex p.
    </p>
  <div align="middle">
  <img src="images/default.png" align="middle" width="800px"/>
    <figcaption align="middle"><i>Default OpenGL shading.</i></figcaption>
  <img src="images/smoothed.png" align="middle" width="800px"/>
    <figcaption align="middle"><i>smoothed normals.</i></figcaption>
    <div/>


<h3 align="middle">Part 4: Half-edge flip</h3>
    <p>
      In order to keep things simple and clean, I name and label every elements with different names that we need change their pointers,
       as the diagram shows. (source: <a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf">Click Here.</a>)
      The benefits of labeling all the elements enable us to quickly link between the diagram we draw and the code we write, therefore make few bugs and
      more easily to debug. Then, there are three new elements we want to add when we flip the edges, which are two new faces
      and a new edge. By looking at the differences, we can easily assign the value for each pointers.
    </p>
    <div align="middle">
      <img src="images/diagram.png" align="middle" width="800px"/>
      <div/>

      <p>
        Notice that it is important to pay attention the orientation of new half edges. For example, if we define the direction
        of h0 to the left instead to the right in the after flip diagram, then the direction of outside half edges will also
        be changed (h7 and h8), causing extra unnecessary work to take care of them. Also, it is important to handle the outside
        half edges correctly. While it doesn't seem to matter if we only flip one or two edges, if we didn't handle the outside
        half edges correctly, we will get catastrophic result once we flip many edges.
      </p>

    <div align="middle">
      <img src="images/before_flip.png" align="middle" width="800px"/>
      <figcaption align="middle"><i>Before edges been flipped.</i></figcaption>
      <img src="images/after_flip.png" align="middle" width="800px"/>
      <figcaption align="middle"><i>After edges been flipped.</i></figcaption>
      <div/>


<h3 align="middle">Part 5: Half-edge split</h3>
      <p>
        This part is similar to part 4, except we need to keep create new elements (3 edges, 2 faces, 1 vertex
        and 6 half edges.) and keep track of more things. Therefore, I labeled all elements to make it easier
        to keep track of them and debug, as illustrated below. There's no special tricks about debugging or implementing. You just
        need to be super careful when assigning pointers, because there are so many elements.
      </p>
      <div align="middle">
        <img src="images/split.jpeg" align="middle" width="800px"/>
        <figcaption align="middle"><i>Notations of all elements.</i></figcaption>
        </div>
      <br>
        <p>
          Also notice that in order to keep as few changed elements as possible, for the illustration of after
          splitting, I first label all the elements that remain unchanged, and then based on those elements(labeled
          in blue), label the changed elements accordingly (the direction of half edges, etc.)
        </p>
        <p>
          As fore debugging, since I label all the elements, it is relatively easier for me, except one time I forgot
          assign half edges for newly created edges, which the program crashes with segmentation fault.
        </p>

        <div align="middle">
        <table style="width=100%">
          <tr>
              <img src="images/before_split.png" align="middle" width="800px"/>
            <figcaption align="middle"><i>Before edge splits</i></figcaption>
          </tr>
          <tr>
              <img src="images/split.png" align="middle" width="800px"/>
            <figcaption align="middle"><i>Some edges splits.</i></figcaption>
          </tr>
            <tr>
              <img src="images/split_and_flip.png" align="middle" width="800px"/>
              <figcaption align="middle"><i>Edges splits and flip.</i></figcaption>
            </tr>
          </tr>
        </table>
    </div>



<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

<h2 align="middle">Section III: Mesh Competition</h2>
<p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Design your own mesh!</h3>

</body>
</html>
